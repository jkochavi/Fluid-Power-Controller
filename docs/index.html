<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cal Poly NFPA Vehicle Challenge: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cal Poly NFPA Vehicle Challenge
   &#160;<span id="projectnumber">Soulenoid Cycle, 2021.</span>
   </div>
   <div id="projectbrief">Support documentation for various mechatronics components on the vehicle.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Cal Poly NFPA Vehicle Challenge Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="s_overview"></a>
Wiki Overview</h1>
<p>Welcome to the official support documentation for Cal Poly's NFPA Fluid Powered Vehicle Challenge team! On this wiki, you will find references and files for various elements of the vehicle's mechatronics system. This wiki will expand as future teams iterate on existing design work. Ownership of the wiki is transferred to the new team; the current team's name and logo are visible on this page as well.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/Logo.png" alt="Soulenoid Cycle Logo" class="inline"/></p>
<h1><a class="anchor" id="s_intro"></a>
Project Introduction</h1>
<p>This report discusses the design and prototyping of a custom CAN node user interface for the electronic control system on a hydraulically-powered vehicle. The vehicle’s hydraulic circuit consists of five solenoid valves, which are actuated in combinations to achieve different vehicle behaviors. A rider applies human power input to the vehicle using a standard bicycle crankset. The crankset’s shaft is coupled with a hydraulic pump that draws fluid from a pressure- neutral reservoir. The pump circulates fluid through a bi-directional hydraulic motor that propels the vehicle. The rider can also release fluid from a pressurized accumulator that applies a “boost” to the vehicle’s speed.</p>
<p>Existing hydraulic and electronic components are provided by HydraForce, Inc. Sourcing all components from a single company lends itself to a well-integrated mechatronics system. However, its functionality is not expandable beyond fluid power control. The system’s industrial Programmable Logic Controller (PLC) only has one inter-controller communication peripheral: CAN bus, and cannot be programmed using open-source languages, such as C++ or Python. This project offers a low-cost, open-source user interface for this mechatronics system using CAN bus.</p>
<h1><a class="anchor" id="s_existing"></a>
Existing Work</h1>
<p>The existing mechatronics system uses a HydraForce ECDR 0506-A electronic valve driver. The vehicle’s operator provides input to the system using three push-buttons, which each represent a unique combination of valve actuations. The ECDR 0506-A, shown in Figure 1, has six inputs, which can be configured to receive an analog voltage or current. With three inputs used for push-buttons, the controller is only capable of reading up to three pressure sensors. An additional CAN node that could relay button presses to the central controller would allow it to interface with additional sensors and inputs.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig1.png" alt="" style="width:400px;height:320px;" class="inline"/> <br  />
<b>Figure 1</b> Existing mechatronics system with the ECDR 0506-A valve driver.</p>
<p>A screen capture of part of the programming for the PLC is shown in Figure 2. The software used for this controller is HF Impulse, which is a tool designed by HydraForce to program their controllers. <br  />
</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig2.png" alt="" style="width:530px;height:300px;" class="inline"/> <br  />
<b>Figure 2</b> Screen capture of block programming for the ECDR 0506-A. <br  />
</p>
<h1><a class="anchor" id="s_requirements"></a>
Project Requirements</h1>
<p>The goal of this project is to provide a user interface that acquires and displays relevant information about the hydraulic vehicle. The user must be able to read the stored accumulator pressure and the speed of the vehicle. The user should also be able to provide input to the mechatronics system using four push buttons; each button activates a unique combination of solenoid valves.</p>
<p>The custom solution must be more cost-effective and space-efficient than existing solutions. The interface should communicate with the existing ECDR 0506-A valve driver on a CAN bus using J1939 or CANopen protocols. Finally, the system must be able to draw power from an existing 14.8V lithium polymer battery.</p>
<h1><a class="anchor" id="s_existingSolutions"></a>
Existing Solutions</h1>
<p>Two existing solutions were considered: an OPUS A3F Wachendorff Display Unit, and a SparkFun Arduino CAN shield. The OPUS display unit is a standalone controller that can communicate with other controllers over a CAN bus. Shown in Figure 3, the display has eight configurable button inputs, a pressable rotary knob, and three additional buttons for navigating an interface. It has a 4.3 inch LCD and touchscreen and has a standard DB-9 connector that can be plugged directly into the ECDR 0506-A.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig3.png" alt="" style="width:400px;height:250px;" class="inline"/> <br  />
<b>Figure 3</b> OPUS A3F Wachendorff Display Unit.</p>
<p>The SparkFun CAN shield is designed to add a CAN communication ability to an Arduino Uno. Shown in Figure 4, it fits over the footprint of an Arduino Uno, and contains an MCP2515 CAN controller and MCP2551 CAN transceiver circuit. Like the OPUS A3F, it carries a standard DB-9 connector that can be plugged directly into the ECDR 0506-A. The breakout module also has a micro-SD card port, a joystick, and an additional port to connect to a SparkFun GPS breakout module.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig4.png" alt="" style="width:350px;height:300px;" class="inline"/> <br  />
<b>Figure 4</b> SparkFun CAN bus shield for Arduino Uno.</p>
<p>This product’s main advantage is that SparkFun has already written Arduino code for interfacing with it. SparkFun provides clear and open-source documentation that allows for quick software debugging. However, this product limits the system’s microcontroller to an Arduino Uno’s ATmega328. Discussed further in <a class="el" href="index.html#s_uc">Microcontroller Selection</a>, the Arduino Uno may be insufficient for navigating a complex user interface with a Real Time Operating System (RTOS).</p>
<h1><a class="anchor" id="s_uc"></a>
Microcontroller Selection</h1>
<p>This section describes the selection process for the CAN node’s microcontroller and its other hardware components. The Arduino framework in C++ was chosen as this project’s software basis. The Arduino framework is well-documented, open-source, and can be used to program a variety of microcontrollers and development boards. Two microcontrollers were considered: an ATmega328, and an STM32. ATmega328, produced by Atmel, is an 8-bit AVR microcontroller commonly found on Arduino modules. STM32 is a family of 32-bit ARM microcontrollers produced by STMicroelectronics. Both ATmega328 and STM32 microcontrollers are available on development boards that carry small footprints. Shown in Figure 5, the Arduino Nano and Blue Pill development boards are both relatively small and carry many useful software and hardware peripherals.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig5.png" alt="" style="width:350px;height:150px;" class="inline"/> <br  />
<b>Figure 5</b> Arduino Nano with ATmega328 (left) and STM32 Blue Pill (right).</p>
<p>The biggest advantage of using an Arduino development board, such as the Arduino Nano of Figure 4, is that its microcontroller is preloaded with the Arduino bootloader. This allows the programmer to upload C++ code directly to the board, which its bootloader uses to program the microcontroller. Conversely, most STM32 development boards require the use of the ST-Link programmer, which is a dedicated controller produced by STMicroelectronics that programs an STM32 in its machine code. Some development boards, such as the Nucleo L476RG, have a built-in ST-Link circuit, however the Blue Pill of Figure 4 carries too small of a footprint to have space for the programmer module.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig6.png" alt="" style="width:350px;height:220px;" class="inline"/> <br  />
<b>Figure 6</b> ST-Link programmer used to program the STM32 Blue Pill development board.</p>
<p>The ST-Link programmer is a separate module, shown above in Figure 1.2.4, that interfaces with an Integrated Development Environment (IDE) on a PC. While the Arduino Nano can simply be programmed from its USB port, the Blue Pill must be programmed using a serial connection to the ST-Link, as it does not have a bootloader.</p>
<p>Although the Arduino Nano is easier to program, its ATmega328 carries less processing power than the STM32. As an 8-bit microcontroller, it is not ideal for an RTOS and also has fewer communication peripherals. For example, the Arduino Nano only has one USART port, while the Blue Pill’s STM32F103 has three. Furthermore, the Arduino Nano may be clocked up to 16 MHz, while the Blue Pill may be clocked up to 72 MHz. Given the tradeoff of ease of programmability and processing power between the Arduino Nano and Blue Pill development boards, it was prudent to design and prototype with both before choosing a final design.</p>
<h1><a class="anchor" id="s_CAN"></a>
CAN Communication Hardware</h1>
<p>While the STM32F103 on the Blue Pill has a built-in CAN controller, it cannot be easily accessed with the Arduino framework. To access its CAN peripheral, the microcontroller must be programmed using STM32CubeIDE, which is an IDE produced by STMicroelectronics. To keep the project as open-source as possible, an external CAN controller was chosen, which allows the microcontroller to be programmed in any IDE using the Arduino framework.</p>
<p>The MCP2515 CAN controller was chosen because it is well-documented with many different open-source C++ libraries. In order to communicate with a CAN bus, the MCP2515 receives commands from a microcontroller using a Serial Peripheral Interface (SPI), and then transmits a CAN message using a CAN transceiver. Two transceivers were considered: the MCP2551 and TJA1050. Shown in Figure 7, the two integrated circuits are housed in slightly different packages and have different pinouts.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig7.png" alt="" style="width:350px;height:220px;" class="inline"/> <br  />
<b>Figure 7</b> MCP2551 (left) and TJA1050 (right) CAN transceivers.</p>
<p>Aside from their physical differences, the transceivers are functionally the same and are both compatible with the MCP2515 CAN controller. The MCP2551 is used on the SparkFun product of Figure 4, while the TJA1050 is used on a standalone CAN breakout module of Figure 8.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig8.png" alt="" style="width:200px;height:120;" class="inline"/> <br  />
<b>Figure 8</b> MCP2515 and TJA1050 CAN bus breakout module.</p>
<h1><a class="anchor" id="s_display"></a>
Display Selection</h1>
<p>In order to design a graphically-pleasing interface that can display text to the rider in clear, large fonts, two full-color LCD options were explored: A 2.8 inch Adafruit touch screen with the ILI9341 LCD driver, and a 2.8 inch Nextion touch screen. Both options are significantly smaller than the OPUS A3F display unit and can be easily driven by a microcontroller programmed with the Arduino framework. The LCD breakout module of Figure 9 is a low-cost, generic version of an Adafruit Arduino Uno shield. The LCD is driven by the ILI9341 LCD driver, which communicates with a microcontroller over SPI. The breakout module also has a resistive touch screen and SD card slot for displaying bitmap images. This module is easy to use with the Adafruit Graphics Library, which is a suite of Arduino code designed to communicate with several Adafruit display products. Its ease of programmability allows for the quick design of complex shapes and text designs, and the LCD’s resolution and brightness are comparable to that of Nextion displays.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig9.png" alt="" style="width:200px;height:120;" class="inline"/> <br  />
<b>Figure 9</b> 2.8 inch LCD with ILI9341 driver.</p>
<p>Since this product is nearly three times as cheap as the Nextion display, it was tested first with an Arduino Nano. A skeleton interface was written in C++ and uploaded to an Arduino Nano using the Arduino IDE. The software, which is located in Appendix A, uses the Adafruit Graphics Library to write data to the screen. The result, shown in Figure 10, was visibly very slow because the Adafruit library uses blocking code to write each shape to the screen. In other words, it was only capable of drawing one independent shape or character at a time without the ability to multitask between communication and pixel-writing.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig10.png" alt="" style="width:400px;height:240;" class="inline"/> <br  />
<b>Figure 10</b> Prototyping with a 2.8 inch LCD with ILI9341 driver and Arduino Nano.</p>
<p>The screen latency was measured as the time elapsed between writing different types of shapes to the screen. Measurements were acquired with the Arduino function, millis(), to calculate a difference in time measurements before and after a shape is written to the screen. The results are quantified in Table 1.</p>
<p><b>Table 1</b> Screen latency of Adafruit Graphics Library with ILI9341 LCD.<br  />
 <img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig11.png" alt="" style="width:400px;height:240;" class="inline"/></p>
<dl class="section author"><dt>Author</dt><dd>Jordan Kochavi </dd></dl>
<dl class="section date"><dt>Date</dt><dd>February 23, 2021 </dd></dl>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
